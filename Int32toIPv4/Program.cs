// Возьмем следующий IPv4-адрес: 128.32.10.1 Этот адрес состоит из 4 октетов, где каждый октет представляет собой один байт (или 8 бит).
// 1-й октет 128 имеет двоичное представление: 10000000,
// 2 - й октет 32 имеет двоичное представление: 00100000,
// 3 - й октет 10 имеет двоичное представление: 00001010,
// 4 - й октет 1 имеет двоичное представление: 00000001,
// таким образом, 128.32.10.1 == 10000000.001000000.00001010.00000001.
// Поскольку указанный выше IP-адрес имеет 32 бита, мы можем представить его как 32-битное число без знака: 2149583361.
// Выполните функцию, которая принимает 32-разрядное число без знака и возвращает строковое представление его IPv4-адреса.

Console.WriteLine(UInt32ToIp(2154959208));

string UInt32ToIp(uint ip)
{
    // Число типа uint (32-битное беззнаковое целое) передается методу GetBytes().
    // Это число хранится в памяти как последовательность из четырех байтов.
    // Например, число 2149583361 в десятичной системе равно 0x08002001 в шестнадцатеричной системе, что соответствует
    // последовательности байтов [0x08, 0x00, 0x20, 0x01].
    byte[] bytes = BitConverter.GetBytes(ip);

    // На компьютерах с архитектурой Little Endian (например, x86) младшие байты числа хранятся первыми.
    // То есть число 0x08002001 будет представлено в памяти в следующем порядке: [0x01, 0x20, 0x00, 0x08].
    // Поэтому после вызова метода GetBytes массив байтов будет содержать именно эти значения.
    if (BitConverter.IsLittleEndian)
    {
        // Для правильного отображения IPv4-адреса необходимо, чтобы байты шли в порядке старшинства слева направо.
        // Если архитектура компьютера использует Little Endian,
        // нужно изменить порядок байтов на противоположный с помощью метода Array.Reverse().
        Array.Reverse(bytes);
    }

    return $"{bytes[0]}.{bytes[1]}.{bytes[2]}.{bytes[3]}";
}